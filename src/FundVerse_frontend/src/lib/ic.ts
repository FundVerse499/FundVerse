import type { _SERVICE as FundVerseBackendService } from "../../../declarations/FundVerse_backend/FundVerse_backend.did";
import type { _SERVICE as FundFlowService } from "../../../declarations/Fund_Flow/Fund_Flow.did";
import type { ActorSubclass } from "@dfinity/agent";
import { Actor, HttpAgent } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { Principal } from '@dfinity/principal';
import { createActor as createFundFlowActorFromDeclarations } from "../../../declarations/Fund_Flow";
import { createActor as createBackendActorFromDeclarations } from "../../../declarations/FundVerse_backend";

export const FundFlow = createFundFlowActorFromDeclarations;
export const FundVerseBackend = createBackendActorFromDeclarations;

export const createFundVerseBackendActor = async (): Promise<ActorSubclass<FundVerseBackendService>> => {
  const { agent } = await createAgent();
  return Actor.createActor(fundVerseBackendIdl as any, {
    agent,
    canisterId: FUNDVERSE_BACKEND_CANISTER_ID,
  }) as ActorSubclass<FundVerseBackendService>;
};

export const createFundFlowActor = async (): Promise<ActorSubclass<FundFlowService>> => {
  const { agent } = await createAgent();
  return Actor.createActor(fundFlowIdl as any, {
    agent,
    canisterId: FUND_FLOW_CANISTER_ID,
  }) as ActorSubclass<FundFlowService>;
};


// Use declarations generated by `dfx generate`
import { idlFactory as fundVerseBackendIdl, canisterId as FUNDVERSE_BACKEND_CANISTER_ID } from '../../../declarations/FundVerse_backend';

// Fallback values until Fund_Flow declarations are generated
// These will be replaced when dfx generate is run
const fundFlowIdl: any = {};
const FUND_FLOW_CANISTER_ID: any = 'placeholder';

// Agent configuration
const isLocal = (import.meta as any).env?.DFX_NETWORK === 'local' || process.env.DFX_NETWORK === 'local';
const host = isLocal ? 'http://localhost:4943' : 'https://ic0.app';

// Create and configure the HTTP agent
const createAgent = async () => {
  const authClient = await AuthClient.create();
  const agent = new HttpAgent({ host, identity: authClient.getIdentity() });
  if (isLocal) {
    try { await agent.fetchRootKey(); } catch {}
  }
  return { agent, authClient };
};

// Create actor instances
// export const createFundVerseBackendActor = async (): Promise<any> => {
//   const { agent } = await createAgent();
//   return Actor.createActor(fundVerseBackendIdl as any, {
//     agent,
//     canisterId: FUNDVERSE_BACKEND_CANISTER_ID,
//   });
// };

// export const createFundFlowActor = async (): Promise<any> => {
//   const { agent } = await createAgent();
//   return Actor.createActor(fundFlowIdl as any, {
//     agent,
//     canisterId: FUND_FLOW_CANISTER_ID,
//   });
// };

// Helper exports for canister IDs as string and Principal
export const FUNDVERSE_BACKEND_CANISTER_ID_STR: string = String(FUNDVERSE_BACKEND_CANISTER_ID);
export const FUND_FLOW_CANISTER_ID_STR: string = String(FUND_FLOW_CANISTER_ID);

export const getCanisterPrincipal = (canisterId: string): Principal => Principal.fromText(canisterId);

// Authentication helpers
export const login = async (): Promise<void> => {
  const authClient = await AuthClient.create();
  return new Promise((resolve, reject) => {
    authClient.login({
      identityProvider: isLocal
        ? 'http://localhost:4943?canisterId=rdmx6-jaaaa-aaaaa-aaadq-cai'
        : 'https://identity.ic0.app',
      onSuccess: () => resolve(),
      onError: (error) => reject(error),
    });
  });
};

export const logout = async (): Promise<void> => {
  const authClient = await AuthClient.create();
  await authClient.logout();
};

export const isAuthenticated = async (): Promise<boolean> => {
  const authClient = await AuthClient.create();
  return authClient.isAuthenticated();
};

// Error handling
export class ICError extends Error { constructor(message: string, public code?: string) { super(message); this.name = 'ICError'; } }
export const handleICError = (error: any): ICError => {
  if (error instanceof ICError) return error;
  if (error?.message?.includes('insufficient funds')) return new ICError('Insufficient funds for this operation', 'INSUFFICIENT_FUNDS');
  if (error?.message?.includes('not authorized')) return new ICError('You are not authorized to perform this action', 'NOT_AUTHORIZED');
  return new ICError(error?.message || 'An unexpected error occurred', 'UNKNOWN');
};
